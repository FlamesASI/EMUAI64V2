

from multiprocessing import cpu_count


class N64(object):
 class N64(object):
    def __init__(self, n):
        self.n = n

    def __str__(self):
        return str(self.n)

    def __repr__(self):
        return self.__str__()

    def __add__(self, other):
        return N64(self.n + other.n)

    def __mod__(self, other):
        return N64(self.n % other.n)

    def __pow__(self, other):
        return N64(self.n ** other.n)

    def __neg__(self):
        return N64(-self.n)

    def __pos__(self):
        return N64(+self.n)

    def __abs__(self):
        return N64(abs(self.n))

    def __invert__(self):
        return N64(~self.n)

    def __lt__(self, other):
        return self.n < other.n

    def __le__(self, other):
        return self.n <= other.n

    def __eq__(self, other):
        return self.n == other.n

    def __ne__(self, other):
        return self.n != other.n

    def __gt__(self, other):
        return self.n > other.n

    def __ge__(self, other):
        return self.n >= other.n

    def __and__(self, other):
        return N64(self.n & other.n)

    def __or__(self, other):
        return N64(self.n | other.n)

    def __xor__(self, other):
        return N64(self.n ^ other.n)

    def __lshift__(self, other):
        return N64(self.n << other.n)

    def __rshift__(self, other):
        return N64(self.n >> other.n)


class N64(object):
 {
     print("Welcome to N64 EMULATOR")
 }
 
 ## write a chip definior for the N64 and M1 PRO
 class N64(object):
    def __init__(self, n):
        self.n = n
    
 class N64(object):
     def __init__(self, n):
         self.n = n

## write the ai that generates the code
class mariogenerator(): {
    print("Generating code...")
    
}
## generate the rom
class romgenerate(): {
    print("Generating rom...")
    
}
romgenerate()
## generate the gui as project 64
class gui(): {  "Generating gui.."}
import tkinter 
tkinter.Tk()
class window(): {
tkinter.WINDOWSIZE(width=800, height=600)
}
print(window)